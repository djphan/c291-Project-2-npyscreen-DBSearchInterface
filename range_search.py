import functions
import os
import time
import npyscreen
import gui
import pdb
import string
import random
NUM_TESTS = 4
RANGE_LEN = 200


class RangeRetrieve(npyscreen.ActionForm):
    def create(self):
        # open the appropriate database
        if gui.arg in {'btree', 'indexfile'}:
            self.db = functions.bsddb.btopen(functions.DA_FILE, "r")
        if gui.arg == 'hash':
            self.db = functions.bsddb.hashopen(functions.DA_FILE, "r")

        def notify_must_be_letter():
            npyscreen.notify_confirm("Your key prefixes must be made up of alpha chars",
                title="Error")

        def timer_bpress():
            # list will be populated with tuples of (search time,
            # search results)
            if gui.arg == 'btree':
                # check to see whether the user has specified prefixes for all the range
                ltrs = string.ascii_lowercase
                try:
                    if str(self.range_start.value) != '' and str(self.range_end.value) !='':
                        for ltr in self.range_start.value.lower():
                            if ltr not in ltrs:
                                notify_must_be_letter()
                                return
                        for ltr in self.range_end.value.lower():
                            if ltr not in ltrs:
                                notify_must_be_letter()
                                return

                        # set the range keys based on the user provided prefixes
                        self.key_pairs = []
                        start_key = self.db.set_location(self.range_start.\
                            value.encode(encoding='UTF-8'))[0]
                        end_key = self.db.set_location(self.range_end.\
                        value.encode(encoding='UTF-8'))[0]
                        self.key_pairs.append((start_key, end_key))

                except Exception as e:
                    notify_must_be_letter()
                    return

            if gui.arg == 'hash':
                # check to see whether the user has specified prefixes for all the range
                ltrs = string.ascii_lowercase
                try:
                    if str(self.range_start.value) != '' and str(self.range_end.value) !='':
                        for ltr in self.range_start.value.lower():
                            if ltr not in ltrs:
                                notify_must_be_letter()
                                return
                        for ltr in self.range_end.value.lower():
                            if ltr not in ltrs:
                                notify_must_be_letter()
                                return

                        # set the range keys based on the user provided prefixes
                        self.key_pairs = []
                        self.key_pairs.append((self.range_start.value.encode(), 
                            self.range_end.value.encode()))
                        

                        #self.key_pairs = []
                        #start_key = self.db.set_location(self.range_start.\
                        #    value.encode(encoding='UTF-8'))[0]
                        #end_key = self.db.set_location(self.range_end.\
                        #value.encode(encoding='UTF-8'))[0]
                        #self.key_pairs.append((start_key, end_key))

                except Exception as e:
                    notify_must_be_letter()
                    return

            self.range_search_data = [] 
            if gui.arg in {'btree', 'indexfile'}:
                for key_pair in self.key_pairs:
                    self.range_search_data.append(self.bt_range_search(key_pair))
            if gui.arg == 'hash':
                for key_pair in self.key_pairs:
                    self.range_search_data.append(self.ht_range_search(key_pair))

            # output the results and range for tests.
            # if the key was user generated just populate the first result
            # if the keys were autogenerated populate all 4 results

            # delete previous values
            self.result1.value = ''
            self.result2.value = ''
            self.result3.value = ''
            self.result4.value = ''

            # if the user self generated the key pair just display the one result
            # otherwise display all 4 results from the auto generated pairs.
            if len(self.key_pairs) == 1:
                self.result1.value = str(self.range_search_data[0][0] * 1000000) +\
                    " : Range " +\
                    str(len(self.range_search_data[0][1]))
            else:
                self.result1.value = str(self.range_search_data[0][0] * 1000000) +\
                    " : Range " +\
                    str(len(self.range_search_data[0][1]))
                self.result2.value = str(self.range_search_data[1][0] * 1000000) +\
                    " : Range " +\
                    str(len(self.range_search_data[1][1]))
                self.result3.value = str(self.range_search_data[2][0] * 1000000) +\
                    " : Range " +\
                    str(len(self.range_search_data[2][1]))
                self.result4.value = str(self.range_search_data[3][0] * 1000000) +\
                    " : Range " +\
                    str(len(self.range_search_data[3][1]))
            
            # output data to answers file
            f = open("answers", "w+")
            for i in range(len(self.range_search_data)):
                for record in self.range_search_data[i][1]:
                    f.write(record[0].decode("utf-8") + '\n')
                    f.write(record[1].decode("utf-8") + '\n\n')
            f.close()
            
            # save the btree key pairs to a file to be used on the hash
            # if they were auto generated
            if gui.arg == 'btree':
                if len(self.key_pairs) == 4:
                    f = open("range_key_pairs", "w+")
                    for i in range(len(self.key_pairs)):
                        f.write(self.key_pairs[i][0].decode("utf-8") + '\n')
                        f.write(self.key_pairs[i][1].decode("utf-8") + '\n')
                    f.close()

        def generate_key_pairs():
            """
            generate pairs of keys for the range search
            static for possible external use
            """
            self.key_pairs = []
            db_keys = self.db.keys()
            if gui.arg in {'btree', 'indexfile'}:
                # if the user hasn't specified a key pair use the auto generator to create
                # 4 key pairs and run the test.
                if self.range_start.value == '' and self.range_end.value == '':
                    for i in range(NUM_TESTS):
                        # generate a random char prefix generates smaller key range
                        # for testing on db size of 1000
                        start_prefix1 = random.choice(string.ascii_letters).lower()
                        start_prefix2 = random.choice(string.ascii_letters[:-1]).lower()
                        start_prefix = start_prefix1 + start_prefix2
                        end_prefix1 = start_prefix1
                        end_prefix2 = chr(ord(start_prefix2) + 1)
                        end_prefix = end_prefix1 + end_prefix2
                        start_key = start_prefix.encode()
                        end_key = end_prefix.encode()
                        self.key_pairs.append((start_key, end_key))
                    return
                else:
                    # if the user has specified their own values let them know they
                    # must fill in alpha values in both fields and then press the start
                    # timing process
                    npyscreen.notify_confirm("If you wish to use your own prefixes please fill\
                        both fiels with alpha chars and press the 'Start timing process button'\
                        ", title="Error")
                    return

            if gui.arg == 'hash':
                # try to retrieve the key pairs used in the btree test
                if not os.path.isfile('range_key_pairs'):
                    choice = npyscreen.notify_ok_cancel("For the most accurate results\
                        perform the range search on the b-tree first. The keys generated on the b-tree\
                        are then saved so that the hash table range search can use the same values.\
                        If you would like to continue using a new set of keys click ok.")
                    if choice == 1:
                        # generate a new set of keys if user insists.
                        for i in range(NUM_TESTS):
                            start_prefix1 = random.choice(string.ascii_lowercase)
                            start_prefix2 = random.choice(string.ascii_lowercase[:-1])
                            start_prefix = start_prefix1 + start_prefix2
                            end_prefix1 = start_prefix1
                            end_prefix2 = chr(ord(start_prefix2) + 1)
                            end_prefix = end_prefix1 + end_prefix2
                            start_key = start_prefix.encode()
                            end_key = end_prefix.encode()
                            self.key_pairs.append((start_key, end_key))
                    else:
                        return

                else:
                    try:
                        f = open("range_key_pairs", "r")
                        for i in range(NUM_TESTS):
                            start_key = f.readline().encode()
                            end_key = f.readline().encode()
                            self.key_pairs.append((start_key, end_key))
                        f.close()
                        return
                    except Exception as e:
                        npyscreen.notify_confirm("Could not open range key pair file from b-tree mode")
                        return

        # create form buttons and fields
        self.nextrely+=1
        self.generate_button = self.add(npyscreen.ButtonPress,
            name="Generate key pairs")
        self.timer_button = self.add(npyscreen.ButtonPress,
            name="Start timing process")
        self.timer_button.whenPressed = timer_bpress
        self.generate_button.whenPressed = generate_key_pairs
        self.nextrely+=1

        self.range_start = self.add(npyscreen.TitleText,
            name="Start Key: ")
        self.range_start.value = ''
        self.range_end = self.add(npyscreen.TitleText,
            name="End Key: ")
        self.range_end.value = ''

        self.nextrely+=1
        self.result1 = self.add(npyscreen.TitleText, 
            name="Result 1: ", editable=False)
        self.result2 = self.add(npyscreen.TitleText, 
            name="Result 2: ", editable=False)
        self.result3 = self.add(npyscreen.TitleText, 
            name="Result 3: ", editable=False)
        self.result4 = self.add(npyscreen.TitleText, 
            name="Result 4: ", editable=False)


    def bt_range_search(self, key_pair):
        # for the time being append to a list but ask about this.
        range_set = []
        t0 = time.time()
        current = self.db.set_location(key_pair[0])
        while current[0] <= key_pair[1]:
            range_set.append(current)
            current = self.db.next() 
        total_time = time.time() - t0
        return (total_time, range_set)

    def ht_range_search(self, key_pair):
        range_set = []
        t0 = time.time()
        end_index_key = self.db.last()[0]
        current_index = self.db.first()
        # iterate through each key/data pair and check whether
        # the key is in the range, if so append.
        while current_index[0] != end_index_key:
            if current_index[0] >= key_pair[0] and \
                current_index[0] <= key_pair[1]:
                    range_set.append(current_index)
            current_index = self.db.next()
        
        # keep last key check outside loop
        if current_index[0] == end_index_key and \
            current_index[0] >= key_pair[0] and \
            current_index[0] <= key_pair[1]:
                range_set.append(current_index)
        total_time = time.time() - t0
        return (total_time, range_set)
        
    def on_ok(self):
        self.db.close()
        self.parentApp.switchFormPrevious()

    def on_cancel(self):
        self.db.close()
        self.parentApp.switchFormPrevious()
